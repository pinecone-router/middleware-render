{"version":3,"file":"index.umd.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["/**\n * This will replace the content fetched from `path` into `selector`.\n * The content is assumed to not be an entire html page but a chunk of it.\n * @param {string} content the html content.\n * @param {string} selector the selector of where to put the content.\n */\nfunction renderContent(content, selector) {\n\t// replace the content of the selector with the fetched content\n\tdocument.querySelector(selector).innerHTML = content;\n}\n\n/**\n * This takes the document fetched, and check if it have any routers.\n * @param {Document} doc\n * @param {string} selector\n * @param {array} routes\n * @returns {object} {doc, routes}\n */\nexport function processRoutersInFetchedDoc(doc, selector, routes) {\n\tlet routersInDoc = doc.querySelectorAll('[x-router]');\n\tswitch (routersInDoc.length) {\n\t\tcase 0:\n\t\t\t// if there is no router in the fetched doc, remove the routes registered\n\t\t\t// but only if the selector is body\n\t\t\tif (selector == 'body') routes = [];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t// the router currently loaded\n\t\t\tlet currentRouter = document.querySelector('[x-router]');\n\t\t\t// if the router in the doc dont have x-router set to 'loaded'\n\t\t\t// thus remove it from the current router element before checking if they're the same\n\t\t\tcurrentRouter.setAttribute('x-router', '');\n\t\t\t// check if the one in fetched doc is the same as the current one\n\t\t\tif (\n\t\t\t\troutersInDoc[0].isEqualNode(\n\t\t\t\t\tdocument.querySelector('[x-router]')\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// if it is, mark the router as loaded, so routes wont be processed again\n\t\t\t\troutersInDoc[0].setAttribute('x-router', 'loaded');\n\t\t\t\t// remove the router element currently in the page, in case it is not within the selector.\n\t\t\t\tdocument.querySelector('[x-router]').remove();\n\t\t\t} else {\n\t\t\t\t// if they're not the same remove the routes, the new ones will be added once this new router is added\n\t\t\t\troutes = [];\n\t\t\t\tdocument.querySelector('[x-router]').remove();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// more than one\n\t\t\tthrow new Error(\n\t\t\t\t'Pinecone Router x-render: there can only be one router in the same page'\n\t\t\t);\n\t}\n\n\treturn { doc, routes };\n}\n\n/**\n * This will replace the content fetched from `path` into `selector`.\n * Unlike renderContent, this will assume the fetched content to be an entire HTML.\n * meaning it needs to process the routes as well.\n * @param {string} content the html content.\n * @param {string} selector the selector of where to put the content.\n * @param {array} routes routes array to be processed.\n * @returns {array} processed routes\n */\nexport function renderPage(content, selector, routes) {\n\tlet doc = new DOMParser().parseFromString(content, 'text/html');\n\tdoc = doc.querySelector(selector);\n\t// This takes the document fetched, remove routers already initialized from it\n\t// and also remove routers initialized but not found in it\n\t// that is for routers that are not needed in this page.\n\tlet r = processRoutersInFetchedDoc(doc, selector, routes);\n\tdoc = r.doc;\n\tcontent = doc.innerHTML;\n\trenderContent(content, selector);\n\twindow.PineconeRouter.routes = r.routes;\n}\n","import { renderPage } from './utils.js';\n\nconst PineconeRouterMiddleware = {\n\t/**\n\t * @property {string} version the version of Pinecone Router this middleware is made for.\n\t */\n\tversion: '0.0.2',\n\t/**\n\t * @property {string} name the name of the middleware.\n\t */\n\tname: 'x-render',\n\t/**\n\t * @property {object} settings the middleware settings.\n\t */\n\tsettings: {\n\t\tenabled: false,\n\t\tselector: 'body',\n\t\tpreload: true,\n\t\t/**\n\t\t * @type {number} milliseconds\n\t\t * @summary time to wait after mouse over a link before preloading a page\n\t\t */\n\t\tpreloadtime: 200,\n\t\t/**\n\t\t * @type {object}\n\t\t * @summary The content that has been preloaded on mouseover event.\n\t\t */\n\t\tpreloaded: { path: null, content: null },\n\t},\n\n\t/**\n\t * This will be called at router initialization.\n\t * used for detecting router settings.\n\t * @param {object} component the router's alpine component.\n\t */\n\tinit(component) {\n\t\tif (\n\t\t\twindow.PineconeRouterMiddlewares.find((m) => m.name == 'x-views') !=\n\t\t\tnull\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Pinecone Router ${this.name}: Cannot use x-render along with x-views.`\n\t\t\t);\n\t\t}\n\n\t\tif (component.$el.hasAttribute('x-render')) {\n\t\t\tif (window.PineconeRouter.settings.hash) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Pinecone Router ${this.name}: Cannot use x-render along with x-hash.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.settings.enabled = true;\n\t\t\t// check if a selector was set\n\t\t\tlet selector = component.$el.getAttribute('x-render');\n\t\t\tif (selector != '') {\n\t\t\t\tthis.settings.selector = selector;\n\t\t\t}\n\t\t\t// this will disable notfound handling in favor of server rendered 404 page\n\t\t\t// this can be overwritten if needed by making a notfound route with a handler\n\t\t\twindow.PineconeRouter.notfound = null;\n\t\t\twindow.PineconeRouter.settings.allowNoHandler = true;\n\t\t}\n\n\t\tthis.interceptLinks();\n\t},\n\n\t/**\n\t * This will intercept links for mouse hover\n\t */\n\tinterceptLinks() {\n\t\tdocument.querySelectorAll('a').forEach((el) => {\n\t\t\t// check if we already intercepted this link\n\t\t\tif (el.hasAttribute('x-link')) return;\n\t\t\t// check if the link is a navigation/relative link\n\t\t\tif (window.PineconeRouter.validLink(el) == false) return;\n\n\t\t\tif (!this.settings.enabled || !this.settings.preload) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tel.addEventListener('mouseover', (e) => {\n\t\t\t\tlet path = e.target.getAttribute('href');\n\t\t\t\tif (path == null) path = '/';\n\t\t\t\tif (this.settings.preloaded.path == path) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\tfetch(path)\n\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\t\tthis.settings.preloaded.path = path;\n\t\t\t\t\t\t\tthis.settings.preloaded.content = response;\n\t\t\t\t\t\t});\n\t\t\t\t}, this.settings.preloadtime);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Will be called after the handlers are executed and done.\n\t * during navigation inside PineconeRouter.navigate().\n\t * @param {object} _route the matched route, null if not found.\n\t * @param {string} path the path visited by the client\n\t * @param {boolean} firstload first page load and not link navigation request\n\t * @param {boolean} notfound set to true if the route wasn't found\n\t * @returns {boolean} false to make the navigate function exit (make sure to send the loadend event); none to continue execution.\n\t */\n\tonHandlersExecuted(_route, path, firstload, notfound) {\n\t\t// if using page rendering and the user just (re)loaded the page\n\t\t// dont fetch the content as it is already loaded\n\t\tif (this.settings.enabled && !firstload && !notfound) {\n\t\t\tif (this.settings.preloaded.path == path) {\n\t\t\t\trenderPage(\n\t\t\t\t\tthis.settings.preloaded.content,\n\t\t\t\t\tthis.settings.selector,\n\t\t\t\t\twindow.PineconeRouter.routes\n\t\t\t\t);\n\t\t\t\tthis.interceptLinks();\n\t\t\t\tthis.settings.preloaded.path = null;\n\t\t\t\tthis.settings.preloaded.content = null;\n\t\t\t\twindow.dispatchEvent(window.PineconeRouter.loadend);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfetch(path)\n\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t})\n\t\t\t\t\t.then((response) => {\n\t\t\t\t\t\trenderPage(\n\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\tthis.settings.selector,\n\t\t\t\t\t\t\twindow.PineconeRouter.routes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.interceptLinks();\n\t\t\t\t\t\twindow.dispatchEvent(window.PineconeRouter.loadend);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n};\n\nif (window.PineconeRouterMiddlewares == null)\n\twindow.PineconeRouterMiddlewares = [PineconeRouterMiddleware];\nelse window.PineconeRouterMiddlewares.push(PineconeRouterMiddleware);\n"],"names":["renderPage","content","selector","routes","doc","DOMParser","parseFromString","querySelector","r","routersInDoc","querySelectorAll","length","document","setAttribute","isEqualNode","remove","Error","processRoutersInFetchedDoc","innerHTML","renderContent","window","PineconeRouter","PineconeRouterMiddleware","version","name","settings","enabled","preload","preloadtime","preloaded","path","init","component","PineconeRouterMiddlewares","find","m","this","$el","hasAttribute","hash","getAttribute","notfound","allowNoHandler","interceptLinks","forEach","el","validLink","addEventListener","e","target","setTimeout","fetch","then","response","text","onHandlersExecuted","_route","firstload","dispatchEvent","loadend","push"],"mappings":"sFAmEgBA,EAAWC,EAASC,EAAUC,GAC7C,IAAIC,GAAM,IAAIC,WAAYC,gBAAgBL,EAAS,aACnDG,EAAMA,EAAIG,cAAcL,GAIxB,IAAIM,WAvDsCJ,EAAKF,EAAUC,GACzD,IAAIM,EAAeL,EAAIM,iBAAiB,cACxC,OAAQD,EAAaE,QACpB,OAGiB,QAAZT,IAAoBC,EAAS,IACjC,MACD,OAEqBS,SAASL,cAAc,cAG7BM,aAAa,WAAY,IAGtCJ,EAAa,GAAGK,YACfF,SAASL,cAAc,gBAIxBE,EAAa,GAAGI,aAAa,WAAY,UAEzCD,SAASL,cAAc,cAAcQ,WAGrCZ,EAAS,GACTS,SAASL,cAAc,cAAcQ,UAEtC,MACD,QAEC,UAAUC,MACT,2EAIH,MAAO,CAAEZ,IAAAA,EAAKD,OAAAA,GAkBNc,CAA2Bb,EAAKF,EAAUC,GAClDC,EAAMI,EAAEJ,IApET,SAAuBH,EAASC,GAE/BU,SAASL,cAAcL,GAAUgB,UAAYjB,EAoE7CkB,CADAlB,EAAUG,EAAIc,UACShB,GACvBkB,OAAOC,eAAelB,OAASK,EAAEL,OC3ElC,MAAMmB,EAA2B,CAIhCC,QAAS,QAITC,KAAM,WAINC,SAAU,CACTC,SAAS,EACTxB,SAAU,OACVyB,SAAS,EAKTC,YAAa,IAKbC,UAAW,CAAEC,KAAM,KAAM7B,QAAS,OAQnC8B,KAAKC,GACJ,GAEC,MADAZ,OAAOa,0BAA0BC,KAAMC,GAAgB,WAAVA,EAAEX,MAG/C,UAAUR,MACR,mBAAkBoB,KAAKZ,iDAI1B,GAAIQ,EAAUK,IAAIC,aAAa,YAAa,CAC3C,GAAIlB,OAAOC,eAAeI,SAASc,KAClC,UAAUvB,MACR,mBAAkBoB,KAAKZ,gDAG1BY,KAAKX,SAASC,SAAU,EAExB,IAAIxB,EAAW8B,EAAUK,IAAIG,aAAa,YAC1B,IAAZtC,IACHkC,KAAKX,SAASvB,SAAWA,GAI1BkB,OAAOC,eAAeoB,SAAW,KACjCrB,OAAOC,eAAeI,SAASiB,gBAAiB,EAGjDN,KAAKO,kBAMNA,iBACC/B,SAASF,iBAAiB,KAAKkC,QAASC,IAEnCA,EAAGP,aAAa,WAEuB,GAAvClB,OAAOC,eAAeyB,UAAUD,IAE/BT,KAAKX,SAASC,SAAYU,KAAKX,SAASE,SAG7CkB,EAAGE,iBAAiB,YAAcC,IACjC,IAAIlB,EAAOkB,EAAEC,OAAOT,aAAa,QACrB,MAARV,IAAcA,EAAO,KACrBM,KAAKX,SAASI,UAAUC,MAAQA,GAIpCV,OAAO8B,WAAW,WACjBC,MAAMrB,GACJsB,KAAMC,GACCA,EAASC,QAEhBF,KAAMC,IACNjB,KAAKX,SAASI,UAAUC,KAAOA,EAC/BM,KAAKX,SAASI,UAAU5B,QAAUoD,KAElCjB,KAAKX,SAASG,kBAcpB2B,mBAAmBC,EAAQ1B,EAAM2B,EAAWhB,GAG3C,GAAIL,KAAKX,SAASC,UAAY+B,IAAchB,EAAU,CACrD,GAAIL,KAAKX,SAASI,UAAUC,MAAQA,EAUnC,OATA9B,EACCoC,KAAKX,SAASI,UAAU5B,QACxBmC,KAAKX,SAASvB,SACdkB,OAAOC,eAAelB,QAEvBiC,KAAKO,iBACLP,KAAKX,SAASI,UAAUC,KAAO,KAC/BM,KAAKX,SAASI,UAAU5B,QAAU,KAClCmB,OAAOsC,cAActC,OAAOC,eAAesC,YAG3CR,MAAMrB,GACJsB,KAAMC,GACCA,EAASC,QAEhBF,KAAMC,IACNrD,EACCqD,EACAjB,KAAKX,SAASvB,SACdkB,OAAOC,eAAelB,QAEvBiC,KAAKO,iBACLvB,OAAOsC,cAActC,OAAOC,eAAesC,iBAQT,MAApCvC,OAAOa,0BACVb,OAAOa,0BAA4B,CAACX,GAChCF,OAAOa,0BAA0B2B,KAAKtC"}